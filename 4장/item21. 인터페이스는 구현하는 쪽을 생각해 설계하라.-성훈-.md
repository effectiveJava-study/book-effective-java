## item21. 인터페이스는 구현하는 쪽을 생각해 설계하라.
---
### 인터페이스의 세상은 2개로 나뉜다.

**자바7 까지의 세상**
**자바8 이후의 세상**
>자바7와 자바8의 차이점은 static method와 default method의 사용 유무이다.



자바 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가 할 방법이 없었다.
인터페이스 메서드를 추가하면 보통은 컴파일 오류가 나는데, 추가된 메서드가 우현히 기존 구현체에 이미 존재할 가능성은 아주 낮기 때문.

자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만, 위험이 완전히 사라진 것은 아니다.

디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.

* 디폴트 메서드는 기존 구현체인 런타임 오류를 일으킬 수 있다.

* 디폴트 메서드를 추가하면 기존 구현체에 영향을 줄 수 있다,

* 기존 인터페이스에 새로운 디폴트 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야한다.

>디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주위를 기울여야 한다. 디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 커다란 위험도 딸려 온다. 인터페이스에 내재된 작은 결함도 사용자 입장에서 짜증이 나는데, 심각하게 잘못된 인터페이스라면 이를 포함한 API에 어떤 재앙을 몰고 올지 알 수 없다.

---
### Static Method
static이 붙은 녀석들은 JVM이 시작될 때 Method(static) 영역에 저장된다. 그리고 프로그램이 끝날 때까지 사라지지 않고 메모리에 남아있다. (자바 기준)

```
public class LottoNumberFactory {
    private static final int MIN_LOTTO_NUMBER = 1;
    private static final int MAX_LOTTO_NUMBER = 45;
    private static final int LOTTO_LENGTH = 6;

    private static List<LottoNumber> lottoNumbers = new ArrayList<>();

    //45개의 로또 숫자 초기화
    static {
        for (int i = MIN_LOTTO_NUMBER; i <= MAX_LOTTO_NUMBER; i++) {
            lottoNumbers.add(new LottoNumber(i));
        }
    }

    public static List<LottoNumber> createLottoNumbers() {
        List<LottoNumber> lotto = new ArrayList<>();
        Collections.shuffle(lottoNumbers);
        for (int i = 0; i < LOTTO_LENGTH; i++) {
            lotto.add(lottoNumbers.get(i));
        }
        return lotto;
    }
}
```
#### 속도가 빨라지고 공유(반복적인 사용)에 효율적이다.

createLottoNumbers() 메소드는 6개의 당첨번호를 추첨할 때, 그리고 자동으로 로또를 구입할 때 호출된다. static으로 선언되어 있으므로 메소드를 사용할 때 마다 반복적으로 LottoNumberFactory객체를 생성해 줄 필요 없다. 생성자를 호출할 필요가 없으니 당연히 속도도 빨라질 수밖에 없다. 위 메소드를 호출하기 위해 필요한 것은 단지 클래스 이름과 메소드 이름뿐이다.

#### 객체 지향에서 멀어지고, 메모리 효율이 떨어질 수 있다.

`static` 은 객체 지향보다는 절차 지향에 가까운 키워드다. `static` 키워드는 C의 전역 변수/함수와 성격이 비슷하다. 정적 메소드는 객체의 생성, 제거와 관계없이 프로그램 시작부터 끝날 때까지 메모리에 남아있기 때문

정적 메소드는 객체를 생성하지 않고 사용한다. 반복적으로 객체를 생성하지 않아도 되니 메모리 효율에 좋을 것 같다는 생각이 들 수도 있지만
`static`이 붙은 메소드 등은 GC에 포함이 되어있지 않는다 (`static` 영역은 GC의 대상이 아님) GC는 동적으로 할당된 메모리만 대상으로 함
그래서 `static` 영역이 지나치게 많은 메모리를 차지하고 있다면 메모리 효율이 떨어짐

---

### Default Method
인터페이스는 기능에 대한 선언만 가능하기 때문에, 실제 코드를 구현한 로직은 포함될 수 없다.

하지만 자바8에서 이러한 룰을 깨트리는 기능이 나오게 되었는 데 그것이 `Default Method`이다.

메소드 선언 시에 default를 명시하게 되면 인터페이스 내부에서도 로직이 포함된 메소드를 선언할 수 있다.

```
interface MyInterface { 
    default void printHello() { 
    	System.out.println("Hello World"); 
    } 
}
```
default라는 키워드를 메소드에 명시하게 되면 인터페이스 내부라도 코드를 작성할 수 있음.

### 왜씀?
사실 인터페이스는 기능에 대한 구현보다는, 기능에 대한 `선언`에 초점을 맞추어 사용함

>`하위 호환성`때문이다. 
예를 들어 설명하자면, 여러분들이 만약 오픈 소스코드를 만들었다고 가정하자. 그 오픈소스가 엄청 유명해져서 전 세계 사람들이 다 사용하고 있는데, 인터페이스에 새로운 메소드를 만들어야 하는 상황이 발생했다. 자칫 잘못하면 내가 만든 오픈소스를 사용한 사람들은 전부 오류가 발생하고 수정을 해야 하는 일이 발생할 수도 있다. 이럴 때 사용하는 것이 바로 default 메소드다. (자바의 신 2권)


* 바이너리 호환성 (뭔가를 바꾼 이후에도 에러없이 기존 바이너리가 실행될 수 있는 상황)

* 소스 호환성 (코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있는 상황)

* 동작 호환성 ( 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 하는 상황)


---


> **`핵심:`**
* 기존 인터페이스에는 꼭 필요한 경우가 아니면 디폴트 메서드는 추가하지 않는 것이 좋다.
>
>
* 디폴트 메서드라는 도구가 있지만 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.
>
>
* 새로운 인터페이스라면 릴리즈 전에 반드시 테스트를 거쳐야 한다.
