## 22. 인터페이스는 타입을 정의하는 용도로만 사용하라
인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.

`컴퓨터 메모리는 0과 1의 나열일 뿐이다 따라서 사람들은 각 비트열에 특정한 의미를 부여했는데 숫자형, 문자열, 논리형으로 분리했고 이는 '타입 시스템'이 됐다. 이것의 목적은 데이터가 잘못 사용되는 것을 방지한다.` -객체지향의 사실과 오해<br>

이러한 원래 목적에 맞지 않게 사용하는 안티패턴이 있는데 그 중 하나가 상수 인터페이스다.

```
public interface PhysicalConstants{
    static final double AVOGADROS_NUMBER = 6.022_140_857e23;
    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
    static final double ELECTRON_MASS = 9.109.383_56e-31;
}
```

상수 인터페이스는 인터페이스를 잘못 사용한 예인데 클래스 내부에서 사용하는 상수는 인터페이스가 아니라 내부 구현에 해당한다. 위의 구현은 내부 구현을 클래스의 API에 노출하는 행위다. 이런 인터페이스는 사용자에게 아무런 이점도 주지 못한다. 

더 나아가 심하게는 클라이언트 코드가 이 상수들에 종속되게 한다. 그래서 다음 릴리즈에서 위의 상수를 사용하지 않더라고 바이너리 호환성을 위해 여전히 상수 인터페이스를 구현하고 있어야 한다.
예를 들어 위의 인터페이스를 구현한 클래스가 final이 아니라면 그 클래스를 상속받는 클래스가 나올 수 있고 그렇게 되면 종속 클래스들 때문에 문제가 복잡해진다.

* 바이너리 호환성: 클래스를 수정할 때 그 클래스를 사용하는 다른 클래스를 리컴파일 하지 않아도 되게 하는 것.

상수 공개 목적이라면 열거 타입으로 만들어 공개하거나(아이템 34) 인스턴스화 할 수 없는 유틸리티 클래스에 담아서 공개하면 된다.

```
public class PhysicalContants{
    private PhysicalConstants(){}
    static final double AVOGADROS_NUMBER = 6.022_140_857e23;
    static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
    static final double ELECTRON_MASS = 9.109.383_56e-31;
}
```
추가로 정적 임포트를 이용하면 더 편하다.

결론: 인터페이스는 타입 정의 용도로만 사용하고 상수 공개용으로 사용하지 말자.
