### **불변클래스** :

 - 그 인스턴스의 내부 값을 수정할 수 없는 클래스.

 - 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않음.

 - 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전.

 - 한번 만든 인스턴스를 최대한 재활용하기를 권함

```java
// 자주 쓰이는 값들을 상수로 제공하는 가장 쉬운 재활용방법중 Complex클래스 예시
public static final Complex ZERO = new Complex(0,0);
public static final Complex ONE = new Complex(1,0);
public static final Complex I = new Complex(0,);
```

 - 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있음

<br>

**클래스를 불변으로 만들수있는 규칙**

1. 객체의상태를 변경하는 메스드(변경자)를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.(하위 클래스에서 부주의해 객체의 상태를 변하게 만드는 사태를 막아줌)
3. 모든 필드를 final로 선언한다. (시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법)
4. 모든 필드를 private로 선언한다. (필드가 참조하는 가변객체를 클라이언트에서 직접 접근해 수정하는 일을막아줌.)
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. (클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야함.)

<br>

**불변 클래스를 만드는 설계방법** 

 - 모든 생성자를 `private`혹은 `package-private`로 만들고 `public` 정적팩터리를 제공

다수의 구현 클래스를 활용한 유연성을 제공하고 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있음

```java
//생성자 대신 정적팩터리를 사용한 불변클래스 예시
public class Complex {
	private final double re;
	private final double im;

	private Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}
	public static Complex valueOf(double re, double im) {
		return new Complex(re, im);
	}
	...//나머지 코드 생략
}
```

---

### **불변 객체** :

 - 단순함

 - 생성된 시점의 상태를 파괴될 때 까지 그대로 간직함

 - 근본적으로 스레드 안전하여 따로 동기화할 필요 없음

 - 불변 객체에 대해서는 그 어떤 스레드도 다른스레드에 영향을 줄 수 없으니 안심하고 공유할 수 있음

 - 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있음

 - 객체를 만들 때 다른 불변 객체들을 구성 요소로 사용하면 이점이 많음 

(값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문)

 - 그 자체로 실패 원자성을 제공

(상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.)

**단점** : 값이 다르면 반드시 독립된 객체로 만들어야 함

***가변 객체** : 임의의 복잡한 상태에 놓일 수 있다. 변경자 메서드가 일으키는 상태 전이를 정밀하게 문서로 남겨놓지 않은 가변 클래스는 믿고 사용하기 어려울 수 있음.*

---

### 정리

- 게터(getter)가 있다고 해서 무조건 세터(setter)를 만들지는 말자. **클래스는 꼭 필요한 경우가 아니라면 불변 이어야 한다.**
- 모든 클래스를 불변으로 만들 수는 없다. **불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.**
- **다른 합당한 이유가 없다면**(꼭 변경해야할 필드) **필드는 private final이어야 한다.**
- **생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.**
