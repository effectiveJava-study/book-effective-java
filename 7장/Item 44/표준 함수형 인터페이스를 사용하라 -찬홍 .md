# 표준 함수형 인터페이스를 사용하라.

- 자바가 람다를 지원하면서 API를 작성하는 모범 사례도 크게 바뀌었다.
- 상위 클래스의 기본 메서드를 재저으이해 원하는 동작을 구현하는 템플릿 메서드 패턴의 매력이 크게 줄었다.
- 이를 대체하는 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 것이다.
- 함수 객체를 매개변수로 받는 생성자와 메서드를 더 많이 만들어야 한다. 이때 함수형 매개변수 타입을 올바르게 선택해야 한다.

<br>

### 불필요한 함수형 인터페이스 - 대신 표준 함수형 인터페이스를 사용하라.

---

- `LinkedHashMap` 클래스의 protected 메서드인 `removeEldestEntry`를 재정의 하면 캐시로 사용할 수 있다.
- 맵에 새로운 키를 추가하는 `put` 메서드는 이 메서드를 호출하여 `true`가 반환되면 맵에서 가장 오래된 원소를 제거한다.
- 다음 처럼 맵에 원소가 100개 될 때 까지 커지다가, 그 이상이 되면 가장 오래된 원소를 제거한다.

```java
protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
		return size() > 100;
}
```

> 잘 동작하지만 람다를 사용하면 훨씬 잘 해낼 수 있다.
> 
- `LinkedHashMap`을 오늘날 다시 구현한다면 함수 객체를 받는 정적 팩터리나 생성자를 제공했을 것이다.
- `removeEldestEntry` 선언을 보면 이 함수 객체는 `Map.Entry<K, V>`를 받아 `boolean`을 반환해야 할 것 같지만, 꼭 그렇지는 않다.
- `removeEldestEntry`는 `size()`를 호출해 맵 안의 원소 수를 알아내는데, `removeEldestEntry`가 인스턴스 메서드라서 가능한 방식이다.
- 하지만 생성자에 넘기는 함수 객체는 이 맵의 인스턴스 메서드가 아니다. 팩터리나 생성자를 호출할 때는 맵의 인스턴스가 존재하지 않기 때문이다. 따라서 맵은 자기 자신도 함수 객체에 건네줘야 한다.
- 이를 함수형 인터페이스로 만들면 다음과 같다.

<br>

## 표준 함수형 인터페이스

---

```java
@FuntionalInterface 
interface EldestEntryRemovalFunction<K, V> {
		boolean remove(Map<K, V> map, Map.Entry<K, V> eldest);
}
```

- 자바 표준 라이브러리에 이미 같은 모양의 인터페이스가 준비되어 있기 때문이다.
- java.util.function 패키지를 보면 다양한 용도의 표준 함수형 인터페이스가 담겨있다.
- 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용해야 한다.
- 유용한 디폴트 메서드들 많이 제공하므로 다른 코드와의 상호운용성도 크게 좋아질 것이다.
    - `Predicate` 인터페이스는 프레디키트(predicate)들을 조합하는 메서드를 제공한다.
    - 앞의 `LinkedHashMap` 예에서는 직접 만든 `EldestEntryRemoveFunction` 대신 표준 인터페이스인 `BiPredicate<Map<K, V>, Map.Entry<K, V>>`를 사용할 수 있다.

<br>

## Java.util.function 패키지의 기본 인터페이스 6개

- Java.util.function 패키지에는 총 43개의 인터페이스가 담겨있다. 전부 기억하긴 어렵겠지만, 기본 인터페이스 6개만 기억하면 나머지를 충분히 유추해낼 수 있다.
- 이 기본 인터페이스들은 모두 참조 타입용이다.
![image](https://user-images.githubusercontent.com/90807343/165933563-7d40184c-6b84-4152-98fb-daaca6accb22.png)

- 기본 인터페이스는 기본 타입인 `int`, `long`, `double`용으로 각 3개씩 변형이 생겨난다.
- 그 이름도 기본 인터페이스의 이름 앞에 해당 기본 타입 이름을 붙여 지었다.
    - `int`를 받는 `Predicate`는 `IntPredicate`, `long`을 받아 `long`을 반환하는 `BinaryOperator`는 `LongBinaryOperator`
- 이 변형들 중 유일하게 `Function`의 변형만 매개변수화 됐다. 정확히는 반환 타입만 매개변수화 됐는데, 예를 들어 `LongFunction<int[]>`은 `long`인수를 받아 `int[]`을 반환한다.
    - `Function` 인터페이스에는 기본 타입을 반환하는 변형 총 9개가 존재한다.
    - 입력과 결과 타입이 모두 기본타입이면 **SrcToResult** 사용
        - `long`을 받아 `int` 반환하면 `LongToIntFunction` (총 6개)
    - 입력을 매개변수화하면 **ToResult** 사용 ****
        - `ToLongFunction<int[]>`은 `int[]`인수를 받아 `long`을 반환 (총 3개)

- 이러한 인터페이스까지 총 43개이다. 외우기 힘들고 규칙성도 부족하다.
- 하지만 실무에서 자주 쓰이는 함수형 인터페이스 중 상당수를 제공하며, 필요할 때 찾아 쓸 수 있을 만큼은 범용적인 이름을 사용했다.

---

- 표준 함수형 인터페이스 대부분은 기본 타입만 지원한다. **그렇다고 기본 함수형 인터페이스에 박싱된 기본타입을 넣어 사용하지는 말자**
- 동작은 하지만 “박싱된 기본 타입 대신 기본타입을 사용하라”라는 아이템 61의 조언을 위배한다. 특히 계산량이 많을 때는 성능이 처참히 느려질 수 있다.

<br>

## 표준 함수형 인터페이스가 아니라 전용 함수형 인터페이스를 구현해야하는 상황

- 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
- 반드시 따라야 하는 규약이 있다.
- 유용한 디폴트 메서드를 제공할 수 있다.

전용 함수형 인터페이스를 작성하기로 했다면, 자신이 작성하는 게 다른것도 아닌 ‘인터페이스’임을 명심해야 한다. 아주 주의해서 설계해야 한다는 뜻이다. 

<br>

## `@FunctionalInterface` 애너테이션

- 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
- 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
- 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.
- **직접 만든 함수형 인터페이스에는 항상 `@FunctionalInterface` 애너테이션을 사용해야만 한다.**

<br>

## 함수형 인터페이스를 사용할 때의 주의점

- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안된다.
- 클라이언트에게 불필요한 모호함만 안겨줄 뿐이며, 이 모호함으로 인해 실제로 문제가 일어나기도 한다.
- 이런 문제를 피하는 가장 쉬운 방법은 서로 다른 함수형 인터페이스를 같은 위치의 인수로 사용하는 다중정의를 피하는 것이다.

<br>

## 핵심 정리

- 입력값과 반환값에 함수형 인터페이스 타입을 활용하라
- 보통은 `java.util.function` 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다.
- 단, 흔치는 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 수도 있음을 잊지말자.
